import WebSocket from 'ws';
export class CDPSession {
    ws;
    pendingRequests = new Map();
    eventListeners = new Map();
    messageId = 0;
    sessionId = null;
    constructor(ws) {
        this.ws = ws;
        this.ws.on('message', (data) => {
            try {
                const message = JSON.parse(data.toString());
                if ('id' in message) {
                    const response = message;
                    const pending = this.pendingRequests.get(response.id);
                    if (pending) {
                        this.pendingRequests.delete(response.id);
                        if (response.error) {
                            pending.reject(new Error(response.error.message));
                        }
                        else {
                            pending.resolve(response.result);
                        }
                    }
                }
                else if ('method' in message) {
                    const event = message;
                    if (event.sessionId === this.sessionId || !event.sessionId) {
                        const listeners = this.eventListeners.get(event.method);
                        if (listeners) {
                            for (const listener of listeners) {
                                listener(event.params);
                            }
                        }
                    }
                }
            }
            catch (e) {
                console.error('[CDPSession] Message handling error:', e);
            }
        });
    }
    setSessionId(sessionId) {
        this.sessionId = sessionId;
    }
    send(method, params) {
        const id = ++this.messageId;
        const message = { id, method, params };
        if (this.sessionId) {
            message.sessionId = this.sessionId;
        }
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                this.pendingRequests.delete(id);
                reject(new Error(`CDP command timeout: ${method}`));
            }, 30000);
            this.pendingRequests.set(id, {
                resolve: (result) => {
                    clearTimeout(timeout);
                    resolve(result);
                },
                reject: (error) => {
                    clearTimeout(timeout);
                    reject(error);
                },
            });
            try {
                this.ws.send(JSON.stringify(message));
            }
            catch (error) {
                clearTimeout(timeout);
                this.pendingRequests.delete(id);
                reject(error instanceof Error ? error : new Error(String(error)));
            }
        });
    }
    on(event, callback) {
        if (!this.eventListeners.has(event)) {
            this.eventListeners.set(event, new Set());
        }
        this.eventListeners.get(event).add(callback);
    }
    off(event, callback) {
        this.eventListeners.get(event)?.delete(callback);
    }
    detach() {
        try {
            for (const pending of this.pendingRequests.values()) {
                pending.reject(new Error('CDPSession detached'));
            }
            this.pendingRequests.clear();
            this.eventListeners.clear();
            this.ws.close();
        }
        catch (e) {
            console.error('[CDPSession] WebSocket close error:', e);
        }
    }
}
export async function getCDPSessionForPage({ page, wsUrl }) {
    const ws = new WebSocket(wsUrl);
    await new Promise((resolve, reject) => {
        ws.on('open', resolve);
        ws.on('error', reject);
    });
    const cdp = new CDPSession(ws);
    const pages = page.context().pages();
    const pageIndex = pages.indexOf(page);
    if (pageIndex === -1) {
        cdp.detach();
        throw new Error('Page not found in context');
    }
    const { targetInfos } = await cdp.send('Target.getTargets');
    const pageTargets = targetInfos.filter((t) => t.type === 'page');
    if (pageIndex >= pageTargets.length) {
        cdp.detach();
        throw new Error(`Page index ${pageIndex} out of bounds (${pageTargets.length} targets)`);
    }
    const target = pageTargets[pageIndex];
    if (target.url !== page.url()) {
        cdp.detach();
        throw new Error(`URL mismatch: page has "${page.url()}" but target has "${target.url}"`);
    }
    const { sessionId } = await cdp.send('Target.attachToTarget', {
        targetId: target.targetId,
        flatten: true,
    });
    cdp.setSessionId(sessionId);
    return cdp;
}
//# sourceMappingURL=cdp-session.js.map