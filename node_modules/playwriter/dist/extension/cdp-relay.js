import { Hono } from 'hono';
import { serve } from '@hono/node-server';
import { createNodeWebSocket } from '@hono/node-ws';
import chalk from 'chalk';
import { EventEmitter } from 'node:events';
import { VERSION } from '../utils.js';
export async function startPlayWriterCDPRelayServer({ port = 19988, host = '127.0.0.1', logger } = {}) {
    const emitter = new EventEmitter();
    const connectedTargets = new Map();
    const playwrightClients = new Map();
    let extensionWs = null;
    const extensionPendingRequests = new Map();
    let extensionMessageId = 0;
    function logCdpMessage({ direction, clientId, method, sessionId, params, id, source }) {
        const noisyEvents = [
            'Network.requestWillBeSentExtraInfo',
            'Network.responseReceived',
            'Network.responseReceivedExtraInfo',
            'Network.dataReceived',
            'Network.requestWillBeSent',
            'Network.loadingFinished'
        ];
        if (noisyEvents.includes(method)) {
            return;
        }
        const details = [];
        if (id !== undefined) {
            details.push(`id=${id}`);
        }
        if (sessionId) {
            details.push(`sessionId=${sessionId}`);
        }
        if (params) {
            if (params.targetId) {
                details.push(`targetId=${params.targetId}`);
            }
            if (params.targetInfo?.targetId) {
                details.push(`targetId=${params.targetInfo.targetId}`);
            }
            if (params.sessionId && params.sessionId !== sessionId) {
                details.push(`sessionId=${params.sessionId}`);
            }
        }
        const detailsStr = details.length > 0 ? ` ${chalk.gray(details.join(', '))}` : '';
        if (direction === 'from-playwright') {
            const clientLabel = clientId ? chalk.blue(`[${clientId}]`) : '';
            logger?.log(chalk.cyan('← Playwright'), clientLabel + ':', method + detailsStr);
        }
        else if (direction === 'from-extension') {
            logger?.log(chalk.yellow('← Extension:'), method + detailsStr);
        }
        else if (direction === 'to-playwright') {
            const color = source === 'server' ? chalk.magenta : chalk.green;
            const sourceLabel = source === 'server' ? chalk.gray(' (server-generated)') : '';
            const clientLabel = clientId ? chalk.blue(`[${clientId}]`) : chalk.blue('[ALL]');
            logger?.log(color('→ Playwright'), clientLabel + ':', method + detailsStr + sourceLabel);
        }
    }
    function sendToPlaywright({ message, clientId, source = 'extension' }) {
        const messageToSend = source === 'server' && 'method' in message
            ? { ...message, __serverGenerated: true }
            : message;
        if ('method' in message) {
            logCdpMessage({
                direction: 'to-playwright',
                clientId,
                method: message.method,
                sessionId: 'sessionId' in message ? message.sessionId : undefined,
                params: 'params' in message ? message.params : undefined,
                source
            });
        }
        const messageStr = JSON.stringify(messageToSend);
        if (clientId) {
            const client = playwrightClients.get(clientId);
            if (client) {
                client.ws.send(messageStr);
            }
        }
        else {
            for (const client of playwrightClients.values()) {
                client.ws.send(messageStr);
            }
        }
    }
    async function sendToExtension({ method, params, timeout = 30000 }) {
        if (!extensionWs) {
            throw new Error('Extension not connected');
        }
        const id = ++extensionMessageId;
        const message = { id, method, params };
        extensionWs.send(JSON.stringify(message));
        return new Promise((resolve, reject) => {
            const timeoutId = setTimeout(() => {
                extensionPendingRequests.delete(id);
                reject(new Error(`Extension request timeout after ${timeout}ms: ${method}`));
            }, timeout);
            extensionPendingRequests.set(id, {
                resolve: (result) => {
                    clearTimeout(timeoutId);
                    resolve(result);
                },
                reject: (error) => {
                    clearTimeout(timeoutId);
                    reject(error);
                }
            });
        });
    }
    async function routeCdpCommand({ method, params, sessionId }) {
        switch (method) {
            case 'Browser.getVersion': {
                return {
                    protocolVersion: '1.3',
                    product: 'Chrome/Extension-Bridge',
                    revision: '1.0.0',
                    userAgent: 'CDP-Bridge-Server/1.0.0',
                    jsVersion: 'V8'
                };
            }
            case 'Browser.setDownloadBehavior': {
                return {};
            }
            case 'Target.setAutoAttach': {
                if (sessionId) {
                    break;
                }
                return {};
            }
            case 'Target.setDiscoverTargets': {
                return {};
            }
            case 'Target.attachToTarget': {
                const targetId = params?.targetId;
                if (!targetId) {
                    throw new Error('targetId is required for Target.attachToTarget');
                }
                for (const target of connectedTargets.values()) {
                    if (target.targetId === targetId) {
                        return { sessionId: target.sessionId };
                    }
                }
                throw new Error(`Target ${targetId} not found in connected targets`);
            }
            case 'Target.getTargetInfo': {
                const targetId = params?.targetId;
                if (targetId) {
                    for (const target of connectedTargets.values()) {
                        if (target.targetId === targetId) {
                            return { targetInfo: target.targetInfo };
                        }
                    }
                }
                if (sessionId) {
                    const target = connectedTargets.get(sessionId);
                    if (target) {
                        return { targetInfo: target.targetInfo };
                    }
                }
                const firstTarget = Array.from(connectedTargets.values())[0];
                return { targetInfo: firstTarget?.targetInfo };
            }
            case 'Target.getTargets': {
                return {
                    targetInfos: Array.from(connectedTargets.values()).map((t) => ({
                        ...t.targetInfo,
                        attached: true
                    }))
                };
            }
            case 'Target.createTarget': {
                return await sendToExtension({
                    method: 'forwardCDPCommand',
                    params: { method, params }
                });
            }
            case 'Target.closeTarget': {
                return await sendToExtension({
                    method: 'forwardCDPCommand',
                    params: { method, params }
                });
            }
        }
        return await sendToExtension({
            method: 'forwardCDPCommand',
            params: { sessionId, method, params }
        });
    }
    const app = new Hono();
    const { injectWebSocket, upgradeWebSocket } = createNodeWebSocket({ app });
    app.get('/', (c) => {
        return c.text('OK');
    });
    app.get('/version', (c) => {
        return c.json({ version: VERSION });
    });
    app.post('/mcp-log', async (c) => {
        try {
            const { level, args } = await c.req.json();
            const logFn = logger?.[level] || logger?.log;
            const prefix = chalk.red(`[MCP] [${level.toUpperCase()}]`);
            logFn?.(prefix, ...args);
            return c.json({ ok: true });
        }
        catch {
            return c.json({ ok: false }, 400);
        }
    });
    app.get('/cdp/:clientId?', upgradeWebSocket((c) => {
        const clientId = c.req.param('clientId') || 'default';
        return {
            onOpen(_event, ws) {
                if (playwrightClients.has(clientId)) {
                    logger?.log(chalk.red(`Rejecting duplicate client ID: ${clientId}`));
                    ws.close(1000, 'Client ID already connected');
                    return;
                }
                playwrightClients.set(clientId, { id: clientId, ws });
                logger?.log(chalk.green(`Playwright client connected: ${clientId} (${playwrightClients.size} total)`));
            },
            async onMessage(event, ws) {
                let message;
                try {
                    message = JSON.parse(event.data.toString());
                }
                catch {
                    return;
                }
                const { id, sessionId, method, params } = message;
                logCdpMessage({
                    direction: 'from-playwright',
                    clientId,
                    method,
                    sessionId,
                    id
                });
                emitter.emit('cdp:command', { clientId, command: message });
                if (!extensionWs) {
                    sendToPlaywright({
                        message: {
                            id,
                            sessionId,
                            error: { message: 'Extension not connected' }
                        },
                        clientId
                    });
                    return;
                }
                try {
                    const result = await routeCdpCommand({ method, params, sessionId });
                    if (method === 'Target.setAutoAttach' && !sessionId) {
                        for (const target of connectedTargets.values()) {
                            const attachedPayload = {
                                method: 'Target.attachedToTarget',
                                params: {
                                    sessionId: target.sessionId,
                                    targetInfo: {
                                        ...target.targetInfo,
                                        attached: true
                                    },
                                    waitingForDebugger: false
                                }
                            };
                            logger?.log(chalk.magenta('[Server] Target.attachedToTarget full payload:'), JSON.stringify(attachedPayload));
                            sendToPlaywright({
                                message: attachedPayload,
                                clientId,
                                source: 'server'
                            });
                        }
                    }
                    if (method === 'Target.setDiscoverTargets' && params?.discover) {
                        for (const target of connectedTargets.values()) {
                            const targetCreatedPayload = {
                                method: 'Target.targetCreated',
                                params: {
                                    targetInfo: {
                                        ...target.targetInfo,
                                        attached: true
                                    }
                                }
                            };
                            logger?.log(chalk.magenta('[Server] Target.targetCreated full payload:'), JSON.stringify(targetCreatedPayload));
                            sendToPlaywright({
                                message: targetCreatedPayload,
                                clientId,
                                source: 'server'
                            });
                        }
                    }
                    if (method === 'Target.attachToTarget' && result?.sessionId) {
                        const targetId = params?.targetId;
                        const target = Array.from(connectedTargets.values()).find(t => t.targetId === targetId);
                        if (target) {
                            const attachedPayload = {
                                method: 'Target.attachedToTarget',
                                params: {
                                    sessionId: result.sessionId,
                                    targetInfo: {
                                        ...target.targetInfo,
                                        attached: true
                                    },
                                    waitingForDebugger: false
                                }
                            };
                            logger?.log(chalk.magenta('[Server] Target.attachedToTarget (from attachToTarget) payload:'), JSON.stringify(attachedPayload));
                            sendToPlaywright({
                                message: attachedPayload,
                                clientId,
                                source: 'server'
                            });
                        }
                    }
                    const response = { id, sessionId, result };
                    sendToPlaywright({ message: response, clientId });
                    emitter.emit('cdp:response', { clientId, response, command: message });
                }
                catch (e) {
                    logger?.error('Error handling CDP command:', method, params, e);
                    const errorResponse = {
                        id,
                        sessionId,
                        error: { message: e.message }
                    };
                    sendToPlaywright({ message: errorResponse, clientId });
                    emitter.emit('cdp:response', { clientId, response: errorResponse, command: message });
                }
            },
            onClose() {
                playwrightClients.delete(clientId);
                logger?.log(chalk.yellow(`Playwright client disconnected: ${clientId} (${playwrightClients.size} remaining)`));
            },
            onError(event) {
                logger?.error(`Playwright WebSocket error [${clientId}]:`, event);
            }
        };
    }));
    app.get('/extension', upgradeWebSocket(() => {
        return {
            onOpen(_event, ws) {
                if (extensionWs) {
                    logger?.log(chalk.yellow('Closing existing extension connection to replace with new one'));
                    extensionWs.close(4001, 'Extension Replaced');
                    // Clear state from the old connection to prevent leaks
                    connectedTargets.clear();
                    for (const pending of extensionPendingRequests.values()) {
                        pending.reject(new Error('Extension connection replaced'));
                    }
                    extensionPendingRequests.clear();
                    for (const client of playwrightClients.values()) {
                        client.ws.close(1000, 'Extension Replaced');
                    }
                    playwrightClients.clear();
                }
                extensionWs = ws;
                logger?.log('Extension connected with clean state');
            },
            async onMessage(event, ws) {
                let message;
                try {
                    message = JSON.parse(event.data.toString());
                }
                catch {
                    ws.close(1000, 'Invalid JSON');
                    return;
                }
                if ('id' in message) {
                    const pending = extensionPendingRequests.get(message.id);
                    if (!pending) {
                        logger?.log('Unexpected response with id:', message.id);
                        return;
                    }
                    extensionPendingRequests.delete(message.id);
                    if (message.error) {
                        pending.reject(new Error(message.error));
                    }
                    else {
                        pending.resolve(message.result);
                    }
                }
                else if (message.method === 'log') {
                    const { level, args } = message.params;
                    const logFn = logger?.[level] || logger?.log;
                    const prefix = chalk.yellow(`[Extension] [${level.toUpperCase()}]`);
                    logFn?.(prefix, ...args);
                }
                else {
                    const extensionEvent = message;
                    if (extensionEvent.method !== 'forwardCDPEvent') {
                        return;
                    }
                    const { method, params, sessionId } = extensionEvent.params;
                    logCdpMessage({
                        direction: 'from-extension',
                        method,
                        sessionId,
                        params
                    });
                    const cdpEvent = { method, sessionId, params };
                    emitter.emit('cdp:event', { event: cdpEvent, sessionId });
                    if (method === 'Target.attachedToTarget') {
                        const targetParams = params;
                        logger?.log(chalk.yellow('[Extension] Target.attachedToTarget full payload:'), JSON.stringify({ method, params: targetParams, sessionId }));
                        // Check if we already sent this target to clients (e.g., from Target.setAutoAttach response)
                        const alreadyConnected = connectedTargets.has(targetParams.sessionId);
                        // Always update our local state with latest target info
                        connectedTargets.set(targetParams.sessionId, {
                            sessionId: targetParams.sessionId,
                            targetId: targetParams.targetInfo.targetId,
                            targetInfo: targetParams.targetInfo
                        });
                        // Only forward to Playwright if this is a new target to avoid duplicates
                        if (!alreadyConnected) {
                            sendToPlaywright({
                                message: {
                                    method: 'Target.attachedToTarget',
                                    params: targetParams
                                },
                                source: 'extension'
                            });
                        }
                    }
                    else if (method === 'Target.detachedFromTarget') {
                        const detachParams = params;
                        connectedTargets.delete(detachParams.sessionId);
                        sendToPlaywright({
                            message: {
                                method: 'Target.detachedFromTarget',
                                params: detachParams
                            },
                            source: 'extension'
                        });
                    }
                    else if (method === 'Target.targetInfoChanged') {
                        const infoParams = params;
                        for (const target of connectedTargets.values()) {
                            if (target.targetId === infoParams.targetInfo.targetId) {
                                target.targetInfo = infoParams.targetInfo;
                                break;
                            }
                        }
                        sendToPlaywright({
                            message: {
                                method: 'Target.targetInfoChanged',
                                params: infoParams
                            },
                            source: 'extension'
                        });
                    }
                    else {
                        sendToPlaywright({
                            message: {
                                sessionId,
                                method,
                                params
                            },
                            source: 'extension'
                        });
                    }
                }
            },
            onClose(event, ws) {
                logger?.log('Extension disconnected');
                // If this is an old connection closing after we've already established a new one,
                // don't clear the global state
                if (extensionWs && extensionWs !== ws) {
                    logger?.log('Old extension connection closed, keeping new one active');
                    return;
                }
                for (const pending of extensionPendingRequests.values()) {
                    pending.reject(new Error('Extension connection closed'));
                }
                extensionPendingRequests.clear();
                extensionWs = null;
                connectedTargets.clear();
                for (const client of playwrightClients.values()) {
                    client.ws.close(1000, 'Extension disconnected');
                }
                playwrightClients.clear();
            },
            onError(event) {
                logger?.error('Extension WebSocket error:', event);
            }
        };
    }));
    const server = serve({ fetch: app.fetch, port, hostname: host });
    injectWebSocket(server);
    const wsHost = `ws://${host}:${port}`;
    const cdpEndpoint = `${wsHost}/cdp`;
    const extensionEndpoint = `${wsHost}/extension`;
    logger?.log('CDP relay server started');
    logger?.log('Host:', host);
    logger?.log('Port:', port);
    logger?.log('Extension endpoint:', extensionEndpoint);
    logger?.log('CDP endpoint:', cdpEndpoint);
    return {
        close() {
            for (const client of playwrightClients.values()) {
                client.ws.close(1000, 'Server stopped');
            }
            playwrightClients.clear();
            extensionWs?.close(1000, 'Server stopped');
            server.close();
            emitter.removeAllListeners();
        },
        on(event, listener) {
            emitter.on(event, listener);
        },
        off(event, listener) {
            emitter.off(event, listener);
        }
    };
}
//# sourceMappingURL=cdp-relay.js.map